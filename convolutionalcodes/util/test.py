""" Test Case Boilerplate for pysim. """

import os
import math
import unittest

from functools import wraps

from amaranth import Signal, Module
from amaranth.sim import Simulator


def sync_test_case(process_function, *args, vcd_suffix="", **kwargs):
    """Decorator that converts a function into a simple synchronous-process test case."""

    #
    # This function should automatically transform a given function into a pysim
    # synch process _without_ losing the function's binding on self. Accordingly,
    # we'll create a wrapper function that has self bound, and then a test case
    # that's closed over that wrapper function's context.
    #
    # This ensure that self is still accessible from the decorated function.
    #

    def run_test(self):
        @wraps(process_function)
        def test_case():
            yield from self.initialize_signals()
            yield from process_function(self)

        self.dut = self.instantiate_dut(*args, **kwargs)

        # Ensure there is always something in the synchronous domain
        m = Module()
        dummy = Signal()
        m.submodules.dut = self.dut
        m.d.sync += dummy.eq(dummy)

        self.sim = Simulator(m)
        self.add_clocks()
        self.sim.add_sync_process(test_case, domain=self.domain)
        self.simulate(
            vcd_suffix=process_function.__name__.rpartition("test_")[2] + vcd_suffix
        )

    return run_test


def sync_test_case_convolutional_k_3_4_5_7(process_function, *args, **kwargs):
    """Decorator that converts a function into a synchronous-process test case for
    convolutional codes with constraint length k=3,4,5 and 7."""

    def run_test(self):
        for k in [3, 4, 5, 7]:
            sync_test_case(process_function, *args, k=k, vcd_suffix=f"_k{k}", **kwargs)(
                self
            )

    return run_test


class TestCase(unittest.TestCase):
    domain = "sync"

    # Convenience property: if set, instantiate_dut will automatically create
    # the relevant fragment with FRAGMENT_ARGUMENTS.
    FRAGMENT_UNDER_TEST = None
    FRAGMENT_ARGUMENTS = {}
    CLOCK_FREQUENCY = 1e6

    def add_clocks(self):
        """Add clocks to the simulation. By default, it adds a single clock"""
        self.sim.add_clock(1 / self.CLOCK_FREQUENCY, domain=self.domain)

    def instantiate_dut(self):
        """Instantiate the device-under-test. By default, it instantiates
        FRAGMENT_UNDER_TEST.

        """
        return self.FRAGMENT_UNDER_TEST(**self.FRAGMENT_ARGUMENTS)

    def get_vcd_name(self):
        """Return the name to use for any VCDs generated by this class."""
        if not os.path.exists("waves"):
            os.makedirs("waves")

        return "waves/{}".format(self.__class__.__name__)

    def initialize_signals(self):
        """Provide an opportunity for the test apparatus to initialize siganls."""
        yield Signal()

    def traces_of_interest(self):
        """Returns an interable of traces to include in any generated output."""
        return ()

    def simulate(self, *, vcd_suffix=None):
        """Runs our core simulation."""

        # If we're generating VCDs, run the test under a VCD writer.
        if os.getenv("GENERATE_VCDS", default=False):

            # Figure out the name of our VCD files...
            vcd_name = self.get_vcd_name()
            if vcd_suffix:
                vcd_name = "{}_{}".format(vcd_name, vcd_suffix)

            # ... and run the simulation while writing them.
            traces = self.traces_of_interest()
            with self.sim.write_vcd(
                vcd_name + ".vcd", vcd_name + ".gtkw", traces=traces
            ):
                self.sim.run()

        else:
            self.sim.run()

    @staticmethod
    def pulse(signal, *, step_after=True):
        """Helper method that asserts a signal for a cycle."""
        yield signal.eq(1)
        yield
        yield signal.eq(0)

        if step_after:
            yield

    @staticmethod
    def advance_cycles(cycles):
        """Helper methods that waits for a given number of cycles."""

        for _ in range(cycles):
            yield

    @staticmethod
    def wait_until(strobe, *, timeout=None):
        """Helper method that advances time until a strobe signal becomes true."""

        cycles_passed = 0

        while not (yield strobe):
            yield

            cycles_passed += 1
            if timeout and cycles_passed > timeout:
                raise RuntimeError(f"Timeout waiting for '{strobe.name}' to go high!")
